
# Streams, lazy sequences of data
**Stream** is list-like data abstraction in which items are read in sequential order from stream.
Difference to list is that stream items are generated on-demand basis (lazily).
Benefits of having lazily evaluated sequence of data include:

* possibility to have "infinite" data structures
* enabling composition/pipelining of functions without big memory overhead (compared to lists)
* reduce computing effort as **lazy evaluation** evaluates only what's immediately needed

Streams can be composed, for example having filter -stream to return stream which
filters certain items away from its input stream.

Streams can be pure or impure:

* pure stream: items are generated by pure function
* impure stream: items can be taken from external I/O (file, DB, sockets etc.)

Stream abstraction is not built-in in FunL language, it's implemented as **pair** (list of two items) of:

1. next data value
2. generator function/procedure value which returns next stream (pair)

Read more about [streams from SICP book](https://mitp-content-server.mit.edu/books/content/sectbyfn/books_pres_0/6515/sicp.zip/full-text/book/book-Z-H-24.html#%_sec_3.5).


## Example: infinite stream of prime numbers
**primes.fnl** contains example of pure functional stream.
It demonstrates how several prime numbers are generated from streams on-need basis.
Example shows two ways to read stream:

1. taking one pair from stream
2. taking multiple items from stream as list of items (**take-n**)

It also demonstrates composing streams by having **stream-filter** which
is also stream and filters items away from prime numbers -stream (by applying filtering function).
In this case filtering is done by filtering away prime numbers which include digit 7.

### Running prime numbers example
Infinite prime number stream (and filtering example) are implemented in **primes.fnl**.
Function **take-some-prime-numbers** demonstrates how several prime numbers are taken from stream.

Function **take-prime_numbers-but-no-sevens** demonstrates how prime numbers having 7-digit are
filtered away by using stream-filter (chaining prime number stream to filtering stream).

This example is about pure functional stream usage.

Run example:

```
funla primes.fnl
```

Output:

```
'
Several prime numbers generated on-demand:
list(3, 5, 7, 11, list(13, 17, 19, 23, 29, 31, 37, 41), list(43, 47, 53))

Prime values but ones with digit 7 are filtered away:
list(3, 5, 11, 13, 19, 23, 29, 31, 41, 43, 53, 59, 61)
'
```

### Running lazy file reader example
This example is example of impure stream usage, meaning that reading from stream
may use some external I/O (file, database, socket etc.).
In this example content of **testfile.txt** -file are read in 16 bytes chunks
(this example assumes that **testfile.txt** file exists in same directory).

One chunk is pair (list of two items) of:
1. bool value: **true** if there's no more data to read (EOF), **false** if there's more data to read
2. data from file as bytearray (opaque value, maximum 16 bytes)

Run example:

```
funla lazy_file_reader.fnl
```

Output:

```
'
File in chunks:

list(
        list(
                false
                opaque(bytearray(a 54 68 69 73 20 69 73 20 74 65 73 74 66 69 6c))
        )
        list(
                false
                opaque(bytearray(65 2e a 54 68 69 73 20 69 73 20 32 6e 64 20 6c))
        )
        list(
                true
                opaque(bytearray(69 6e 65 2e a a))
        )
        list(
                true
                opaque(bytearray())
        )
)'
```

